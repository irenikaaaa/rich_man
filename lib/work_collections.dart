//Операції з колекціями
List<int> money = [1000, 2000, 3000, 4000];
Set<int> years = {2015, 2016, 2017, 2018};
Map<int, String> work = {
  1: 'teacher',
  2: 'teacher',
  3: 'programmer',
  4: 'programmer'
};
void main() {
  //money.length - кількість елементів
  //4

  //money.reversed - інвертований список елементів
  //було:[1000, 2000, 3000, 4000]  стало:(4000, 3000, 2000, 1000)

  //money.hashCode - отримуємо хешкод
  //62025449

  //money.runtimeType - тип об'єкту
  //List<int>

  //money.first - перший елемент у списку
  //1000

  //money.isEmpty - отримуємо true, якщо список порожній
  //false

  //money.isNotEmpty - отримуємо true, якщо список НЕ порожній
  //true

  //a.moveNext() - перетворює список в ітератор
  // true
  // true
  // true
  // true
  // false

  //money.last - останній елемент у списку
  //4000

  //money.single - отримуємо елемент списку, якщо список складається тільки з ОДНОГО елемента
  //Bad state: Too many elements

  //money.add(5000) - дадаємо елемент у список
  //[1000, 2000, 3000, 4000, 5000]

  //money.addAll([5000, 6000, 7000]) - додаємо декілька елементів у список
  //[1000, 2000, 3000, 4000, 5000, 6000, 7000]

  //money.any((element) => element == 4000 - true чи false, якщо умова виконується
  // true

  //money.asMap() - отримуємо зі списку мапу
  //{0: 1000, 1: 2000, 2: 3000, 3: 4000}

  //money.cast<int>() - повертає поточний список у вигляді іншого списку
  //[1000, 2000, 3000, 4000]

  //money.clear() - очистити список
  //[]

  //money.contains(1000) - отримуємо true, якщо список містить елемент у дужках
  //true

  //money.elementAt(2) - отримуємо елемент по індексу вказаному в дужках
  //3000

  //money.every((element) => element > 99) - отримуємо true чи false в залежності чи виконується умова
  //true

  //[money, years].expand((element) => element) - отримуємо список iterable, з інших списків
  //(1000, 2000, 3000, 4000, 2015, 2016, 2017, 2018)

  //money.fillRange(1, 3, 77) - заміняє елементи списку на елемент 77 від індекса 1 включно до 3 не включно
  //[1000, 77, 77, 4000]

  //money.firstWhere((element) => element <= 3000 - повертає перший елемент, для якого виконується вказана умова
  //1000

  //money.fold<int>(20, (previousValue, element) => previousValue + element)
  //сума елементів, 20 - перше число, яке також буде в сумі
  //10020

  //money.followedBy([400, 500]) - додає у список нові елементи. Повертає iterable
  //(1000, 2000, 3000, 4000, 400, 500)

  //money.forEach((element) => {print('${element + 200}')}) - до кожного елемента додаємо 200
  //1200
  //2200
  //3200
  //4200

  //money.getRange(0, 2) - отримати зі списку елементи з індексами від 0 включно до 2 НЕвключно
  //(1000, 2000)

  //money.indexOf(2000) - отримати індекс елемента заданого у дужках
  //1

  //money.indexWhere((element) => element > 200) - отримати індекс першого елемента, який задовільняє умову
  //1

  //money.insert(1, 777) - вставити елемент 777 у список з індексом 1. Тобто всі елементи наступні зсуваються
  //Було - [1000, 2000, 3000, 4000]. Стало - [1000, 777, 2000, 3000, 4000]

  //money.insertAll(1, [777, 888]) - вставити елементи новго списку всередину іншого. Перший параметр - це
  //з якого індекса починаючи, вставляти елементи. Всі інші елементи у списку посуваються
  //[1000, 777, 888, 2000, 3000, 4000]

  //money.join(' ♣ ') - отримаємо String. Елементи розділені символом
  //1000 ☻ 2000 ☻ 3000 ☻ 4000

  //money.map((e) => e + 2) - отримуємо список Iterable з додаванням 2
  //(1002, 2002, 3002, 4002)

  //money.remove(2000) - видаляє вказаний елемент. Повертає true чи false, в залежності чи було видалено елемент
  //[1000, 3000, 4000]
  //true

  //money.removeAt(1) - видаляє елемент з вказаним індексом
  //[1000, 3000, 4000]

  //money.removeLast() - видаляє останній елемент зі списку
  //[1000, 2000, 3000]

  //money.removeRange(1, 3) - видаляємо елементи у діапазоні індексів від 1 включно до 3 не включно
  //[1000, 4000]

  //money.removeWhere((element) => element == 3000) - видаляємо елемент в залежності від умови
  //[1000, 2000, 4000]

  //money.retainWhere((element) => element <= 2000) - видаляє елементи, які не відповідають заданій умові
  //[1000, 2000]

  //money.shuffle() - випадковим чином перемішує елементи
  //[2000, 1000, 3000, 4000]

  //money.singleWhere((element) => element == 1000) - повертає елемент, який задовільняє умову
  //якщо таких елементів буде декілька, отримаємо Bad state: Too many elements
  //1000

  //money.skip(2) - отримуємо список Iterable у якому пропускаємо всі елементи до індекса вказаного в дужках
  //(3000, 4000)

  //money.skipWhile((element) => element < 2000) - список Iterable, в якому пропускаємо елементи за умовами
  //анонімної функції
  //(2000, 3000, 4000)

  //money.sort((a, b) => b.compareTo(a)) - сортування від більшого до меншого елемента
  //[4000, 3000, 2000, 1000]

  //money.sublist(1, 2) - отримаємо новий список. Перший параметр - від якого індексу , другий до якого індексу
  // взяти елементи з списку(з якого ств. новий)
  //[2000]

  //money.takeWhile((element) => element < 3000) - список Iterable, за умовами анонімної функції. В даному випадку
  //елементи < 3000
  //(1000, 2000)

  //money.toSet() - перетворити список в Set
  //{1000, 2000, 3000, 4000}

  //years.retainAll({2016, 300, 400}) - отримаємо Set з перетином елементів
  //{2016}

  //years.difference({2017, 300, 400}) - отримаємо Set різницю між списками (заданий {2017, 300, 400} та years)
  //{2015, 2016, 2018}

  //years.union({200, 300, 400}) - отримаємо Set, але не включаючи елементи, що повторяються
  //{2015, 2016, 2017, 2018, 200, 300, 400}

  //money.insertAll(1, [777, 888]) - вставити елементи новго списку всередину іншого. Перший параметр - це
  //з якого індекса починаючи, вставляти елементи. Всі інші елементи у списку посуваються
  //[1000, 777, 888, 2000, 3000, 4000]
  var insert = money.insertAll(1, [777, 888]);
  print(money);

  //work.putIfAbsent(5, () => 'doctor') - додати в список елемент, ключ якого відсутній
  //{1: teacher, 2: teacher, 3: programmer, 4: programmer, 5: doctor}
  var newJob = work.putIfAbsent(5, () => 'doctor');
  print(work);
}
